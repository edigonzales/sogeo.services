<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Interlis leicht gemacht #3</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link href="../../../../css/prettify.css" rel="stylesheet">
    <link href="../../../../css/sogeo.css" rel="stylesheet">

    <!-- web fonts -->
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,700,300' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.019/css/hack.min.css">
    
    <!--[if lt IE 9]>
      <script src="../../../../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../../../../favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
			<li><a href="../../../../index.html">Home</a></li>
			<li><a href="../../../../archive.html">Archive</a></li>
            <li><a href="../../../../feed.xml">Subscribe</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <div class="container">

	<div class="page-header">
		<h1>Interlis leicht gemacht #3</h1>
	</div>

	<p class="date"><em>09 August 2015</em></p>

	<p><div class="paragraph">
<p>Das GeoIG resp. die <a href="https://www.admin.ch/opc/de/classified-compilation/20071088/index.html#a34">GeoIV sieht Downloaddienste</a> für Geobasisdaten vor. Kurzum heisst das, dass diese Geobasisdaten <em>dienstebasiert</em> und <em>modellkonform</em> zum Download bereitgestellt werden. Modellkonform bedeutet - sehr einfach ausgedrückt - entweder INTERLIS/XTF oder <a href="http://www.ech.ch/vechweb/page?p=dossier&amp;documentNumber=eCH-0118">INTERLIS/GML</a>. INTERLIS/GML hat den Vorteil, dass man es, im Gegensatz zu INTERLIS/XTF, sinnvoll mittels WFS bereitstellen kann. Dienstebasiert bedeutet, dass nicht bloss ein einfacher Downloadlink publiziert wird, sondern dass zusätzlich zum Link eine Serviceschicht darüber gestülpt wird.</p>
</div>
<div class="paragraph">
<p>Gedanken über das modellkonforme Bereitstellen von Geodaten hat sich <a href="http://inspire.ec.europa.eu/">INSPIRE</a> auch schon gemacht. Als Lösungen für Downloaddienste werden zwei Alternativen <a href="http://inspire.ec.europa.eu/documents/Network_Services/Technical_Guidance_Download_Services_v3.1.pdf">vorgeschlagen</a>: WFS und Atom + OpenSearch (AtOS). Informationen zu Atom + OpenSearch findet man vor allem in <a href="http://www.weichand.de/masterarbeit/Masterarbeit_Weichand.pdf">zwei</a> <a href="https://www.geoportal.nrw.de/application-informationen/inspire/dokumente/images/Masterthesis_Rohrbach.pdf">Masterarbeiten</a>. Bei Atom + OpenSearch können die (Geo)daten dateibasiert und vordefiniert heruntergeladen werden. Um dem Servicegedanken gerecht zu werden und nicht bloss stupide HTTP-Links zu publizieren, muss noch eine Schicht drüber gelegt werden. Diese pflanzt dem Ganzen ein wenig Intelligenz ein.</p>
</div>
<div class="paragraph">
<p>Setzt man sich mit der modellkonformen Bereitstellung von Geodaten auseinander, darf man zum Schluss kommen, dass die Atom + OpenSearch Lösung einfacher und effizienter für eine GDI umsetzbar ist. Zudem schlägt man zwei Fliegen mit einer Klappe:  neben modellkonformen Daten können ebenfalls nicht-modellkonforme Daten und Rasterdaten mittels Atom + OpenSearch bereitgestellt werden können. WFS kann natürlich trotzdem eingesetzt werden. In diesem Fall aber nicht für die modellkonforme Bereitstellung. Die gerade eben diskutierten Datenflüsse lassen sich grob wie folgt darstellen:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../../../../../images/interlis_leicht_gemacht_p3/gdi.png" alt="GDI Datenbereitstellung">
</div>
</div>
<div class="paragraph">
<p>Das Schema zeigt die beiden Schritte (1) <em>Datenumbau</em> und (2) <em>Formatumbau</em>. Der Datenumbau kann z.B. mit einem ETL-Werkzeug oder auch mit SQL-Befehlen durchgeführt werden. Für den Formatumbau eignet sich ja hervorragend <a href="http://www.eisenhutinformatik.ch/interlis/ili2pg/">ili2pg</a>. Der Formatumbau bei der Variante WFS übernimmt der WFS-Server selbst. Nun könnte man zum Schluss kommen, dass die Variante AtOS weniger aktuell als die WFS-Variante ist: Der WFS greift live auf die Daten des MGDM-Topfs zu wohingegen bei AtOS die Datei z.B. einmal pro Tag mit ili2pg physisch produziert wird. Nun, dem ist nicht so. Eine elegante Lösung ist der Einsatz der ili2pg-Bibliotheken als <a href="https://de.wikipedia.org/wiki/Servlet">Servlet</a>. Damit kann der Formatumbau erst beim Aufruf der URL, z.B. <code><a href="http://www.example.com/2583_schoenenwerd.xtf" class="bare">http://www.example.com/2583_schoenenwerd.xtf</a></code>, ausgeführt werden. Als <em>Proof of Concept</em> soll die amtliche Vermessung der Gemeinde Schönenwerd im Datenmodell <a href="http://www.cadastre.ch/internet/kataster/de/home/manuel-av/service/mopublic.html">MOpublic</a> mittels Servlet erzeugt werden.</p>
</div>
<div class="paragraph">
<p>Als erstes brauchen wir einen Servlet-Container. Anstelle von Java kann man auch - um ein paar Zeichen zu sparen - Groovy einsetzen und sich mit  <a href="http://www.eclipse.org/jetty/">Jetty</a> was zusammenbasteln:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-groovy" data-lang="groovy">#!/usr/bin/env groovy

import org.eclipse.jetty.server.Server
import org.eclipse.jetty.servlet.*
import groovy.servlet.*

@Grab(group='org.eclipse.jetty.aggregate', module='jetty-all', version='9.2.10.v20150310')
def startJetty() {
    def server = new Server(8080)
    def handler = new ServletContextHandler(ServletContextHandler.SESSIONS)
    handler.contextPath = '/'
    handler.resourceBase = '.'
    handler.addServlet(IliExport, '/*')

    server.handler = handler
    server.start()
    server.join()
}

println "Starting Jetty, press Ctrl+C to stop."
startJetty()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interessant sind wahrscheinlich folgende Zeilen:</p>
</div>
<div class="paragraph">
<p><strong>Zeile 7</strong>: Groovy hat mit <a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html">Grape</a> ein effizientes <em>Dependency Management</em>. Fehlt die gewünschte Bibliothek auf dem System, wird sie einmalig heruntergeladen und gespeichert.</p>
</div>
<div class="paragraph">
<p><strong>Zeile 13</strong>: Hier teilen wir dem Server mit, dass bei allen Requests das Servlet <code>IliExport</code> aufgerufen werden soll.</p>
</div>
<div class="paragraph">
<p>Das Formatumbau/Export-Servlet sieht dann wie folgt aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-groovy" data-lang="groovy">@GrabConfig(systemClassLoader=true)
@GrabResolver(name='catais.org', root='http://www.catais.org/maven/repository/release/', m2Compatible='true')
@Grab(group='org.postgresql', module='postgresql', version='9.4-1201-jdbc41')
@Grab(group='ch.interlis', module='ili2c', version='4.5.12')
@Grab(group='ch.interlis', module='ili2pg', version='2.1.4')

import javax.servlet.http.*
import javax.servlet.*
import groovy.servlet.ServletCategory

import ch.ehi.ili2db.base.Ili2db
import ch.ehi.ili2db.base.Ili2dbException
import ch.ehi.ili2db.gui.Config
import ch.ehi.ili2pg.converter.PostgisGeometryConverter
import ch.ehi.sqlgen.generator_impl.jdbc.GeneratorPostgresql

class IliExport extends HttpServlet {
    def application

    void init(ServletConfig config) {
        super.init(config)
        application = config.servletContext
    }

    void doGet(HttpServletRequest request, HttpServletResponse response) {
        def requestedFileName = request.getRequestURI() - '/'

        def mapping = [
        '2583_schoenenwerd.xtf': ['modelname':'MOpublic03_ili2_v13', 'dbschema':'av_mopublic_export'],
        '2583_schoenenwerd.gml': ['modelname':'MOpublic03_ili2_v13', 'dbschema':'av_mopublic_export']
        ]
        def params = mapping.get(requestedFileName)
        def modelName = params['modelname']
        def dbschema = params['dbschema']

        def config = new Config()
        config.setDbhost("localhost")
        config.setDbdatabase("xanadu2")
        config.setDbport("5432")
        config.setDbusr("stefan")
        config.setDbpwd("ziegler12")
        config.setDbschema(dbschema)
        config.setDburl("jdbc:postgresql://localhost:5432/xanadu2")

        config.setModels(modelName);
        config.setModeldir("http://models.geo.admin.ch/");

        config.setGeometryConverter(PostgisGeometryConverter.class.getName())
        config.setDdlGenerator(GeneratorPostgresql.class.getName())
        config.setJdbcDriver("org.postgresql.Driver")

        config.setNameOptimization("topic")
        config.setMaxSqlNameLength("60")
        config.setStrokeArcs("enable")
        config.setSqlNull("enable");
        config.setValue("ch.ehi.sqlgen.createGeomIndex", "True");

        config.setDefaultSrsAuthority("EPSG")
        config.setDefaultSrsCode("21781")

        def tmpDir = System.getProperty('java.io.tmpdir')
        def fileName = tmpDir + File.separator + requestedFileName

        config.setXtffile(fileName)

        Ili2db.runExport(config, "")

        ServletOutputStream os = response.getOutputStream();
        FileInputStream fis = new FileInputStream(fileName);
        try {
            int buffSize = 1024;
            byte[] buffer = new byte[buffSize];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                os.write(buffer, 0, len);
                os.flush();
                response.flushBuffer();
            }
        } finally {
            os.close();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Zeilen 1 -2</strong>: Weil JDBC-Treiber anders geladen werden, müssen wir Grape speziell konfigurieren. Brauchen wir spezielle Mavenrepositories müssen wir diese ebenfalls angeben (Zeile 2).</p>
</div>
<div class="paragraph">
<p><strong>Zeilen 26 - 34</strong>: Sämtliche Requests werden auf dieses Servlet umgeleitet (siehe oben). Der URL-Aufruf entspricht ja eigentlich einem Download einer statischen Datei (INTERLIS/XTF-Datei der Gemeinde Schönenwerd), dh. der Request sieht in unserem Fall wie folgt aus: <code><a href="http://localhost:8080/2583_schoenenwerd.xtf" class="bare">http://localhost:8080/2583_schoenenwerd.xtf</a></code>. Die dazugehörigen Daten liegen in der Datenbank in einem Schema. In welchem Schema steht aber nicht in der URL, sondern das müssen wir mittels Mapping herausfinden. In diesem einfachen Proof of Concept stehen die benötigten Informationen in einer <code>Map</code>. Anstelle der <code>Map</code> ist natürlich auch eine Meta-DB o.ä. vorstellbar. Neben des Speicherortes (Datenbankschema) müssen wir noch den Interlis-Modellnamen kennen.</p>
</div>
<div class="paragraph">
<p><strong>Zeilen 36 - 66</strong>: Die INTERLIS/XTF-Datei wird erzeugt und in ein temporäres Verzeichnis geschrieben (= Formatumbau).</p>
</div>
<div class="paragraph">
<p><strong>Zeilen 68 - 81</strong>: Die gerade eben erzeugte Datei wird an den Klienten gestreamt.</p>
</div>
<div class="paragraph">
<p>Um den Browser nicht zu arg zu belasten (bei 25 MB XML) verwenden wir cURL in der Konsole, um die Datei herunterzuladen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-xml" data-lang="xml">curl http://localhost:8080/2583_schoenenwerd.xtf | xmllint --format -</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mit <code>xmllint</code> wird das heruntergeladene XML noch schön formatiert. Der Formatumbau dauert für die Gemeinde Schönenwerd circa fünf Sekunden und das Resultat kann sich sehen lassen:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../../../../../images/interlis_leicht_gemacht_p3/xtf.png" alt="XTF Output">
</div>
</div>
<div class="paragraph">
<p>Ein Vorteil von ili2pg ist, dass es neben INTERLIS/XTF auch INTERLIS/GML exportieren kann. Der Anwender muss nur <strong>drei</strong> Buchstaben ändern (.xtf &#8594; .gml):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-xml" data-lang="xml">curl http://localhost:8080/2583_schoenenwerd.gml | xmllint --format -</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wiederum fünf Sekunden später erfreuen wir uns über die GML-Datei:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../../../../../images/interlis_leicht_gemacht_p3/gml.png" alt="GML Output">
</div>
</div>
<div class="paragraph">
<p>Je nach Situation (Komplexität und Methode) könnte man auch den Datenumbau (1) gerade beim Aufruf erledigen. In unserem Fall wird der Datenumbau mit SQL-Befehlen gemacht und dauert weniger als eine Sekunde.</p>
</div>
<div class="paragraph">
<p>Eleganter wäre sicher auch wenn man auf das Zwischenspeichern in einer temporären Datei verzichten könnte und ili2pg direkt zum Klienten streamen könnte. Dann muss man auch nicht mehr den Knorz in den Zeilen 68 - 81 durchführen. Soweit ich das verstehe, dürfte das möglich sein, da die darunterliegende Klasse <a href="http://www.eisenhutinformatik.ch/iox-ili/javadocs/ch/interlis/iom_j/xtf/XtfWriter.html">XtfWriter</a> dies bereits unterstützt.</p>
</div>
<div class="paragraph">
<p>Und sollte aus ili2pg irgendwann einmal ein ili2GeoPackage werden, können auch Nicht-PostgreSQL-Anwender diese Bibliotheken verwenden. Man muss bloss den Datenumbau aus dem proprietären System nach GeoPackage machen und den Rest übernimmt ili2GeoPackage&#8230;&#8203;</p>
</div></p>

	<p class="author">
		Posted by Stefan Ziegler. |
		<a href="/tags/INTERLIS.html">INTERLIS</a>
		, <a href="/tags/ili2pg.html">ili2pg</a>
		, <a href="/tags/Java.html">Java</a>
		
	</p>

	<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2016 Stefan Ziegler | Baked with <a href="http://jbake.org">JBake v2.4.0</a></p>
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../../../js/jquery-1.11.1.min.js"></script>
    <script src="../../../../js/bootstrap.min.js"></script>
	<script src="../../../../js/prettify.js"></script>
  </body>
</html>
